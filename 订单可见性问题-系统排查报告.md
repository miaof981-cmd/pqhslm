# 订单可见性问题 - 系统排查报告

**现象**：用户下单后，客服后台和管理员后台能看到订单，但用户端和画师端看不到，且只在个别橱窗出现

**生成时间**：2025-11-11

---

## 📋 排查清单

### ✅ 1. 类型不一致排查

#### **1.1 下单逻辑（✅ 已规范）**

**文件**：`miniprogram/pages/order-success/index.js`（第624-667行）

```javascript
// ✅ 类型已统一为 String
buyerId: String(userId),                    // 用户ID
artistId: String(orderInfo.artistId || ''), // 画师ID
serviceId: String(serviceInfo.serviceId || ''), // 客服ID
```

**结论**：✅ 下单时所有 ID 都已转换为 `String` 类型，符合规范。

---

#### **1.2 过滤逻辑（✅ 已规范）**

**文件**：`miniprogram/utils/order-helper.js`（第416-484行）

```javascript
const toKey = (value) => {
  if (value == null) return ''
  return String(value).trim()  // ✅ 统一转换为 String 并 trim
}

// 用户端过滤
if (role === 'customer') {
  allOrders = allOrders.filter(order => 
    toKey(order.buyerId) === toKey(userId)  // ✅ 类型安全
  )
}

// 画师端过滤
else if (role === 'artist') {
  allOrders = allOrders.filter(order => 
    toKey(order.artistId) === toKey(userId)  // ✅ 类型安全
  )
}
```

**结论**：✅ 过滤逻辑已使用 `toKey()` 函数统一处理，类型安全。

---

### ⚠️ 2. 字段名错误排查

#### **2.1 潜在风险：buyerId vs userId**

**下单时字段**：
- ✅ `buyerId`（正确）
- ✅ `artistId`（正确）

**过滤时字段**：
- ✅ `order.buyerId`（正确）
- ✅ `order.artistId`（正确）

**结论**：✅ 字段名统一，无错误。

---

#### **2.2 潜在风险：artistId 为空字符串**

**问题点**：
```javascript
artistId: String(orderInfo.artistId || '')  // ❌ 如果 artistId 为空，画师端永远看不到
```

**排查建议**：
1. 检查商品详情页传入的 `artistId` 是否正确
2. 检查 `product.artistId` 是否存在且有效

**验证脚本**（在微信开发者工具 Console 执行）：
```javascript
// 检查所有订单的 artistId
const orders = wx.getStorageSync('orders') || []
const emptyArtistIds = orders.filter(o => !o.artistId || o.artistId === '')
console.log('❌ artistId 为空的订单数:', emptyArtistIds.length)
emptyArtistIds.forEach(o => {
  console.log(`订单ID: ${o.id}, artistId: "${o.artistId}", 商品: ${o.productName}`)
})
```

---

### ⚠️ 3. 订单存储位置问题

#### **3.1 订单可能存储在多个位置**

**文件**：`miniprogram/utils/order-helper.js`（第387-407行）

```javascript
function getAllOrders() {
  const legacyOrders = wx.getStorageSync('mock_orders') || []
  const orders = wx.getStorageSync('orders') || []             // ✅ 主订单表
  const pendingOrders = wx.getStorageSync('pending_orders') || []
  const completedOrders = wx.getStorageSync('completed_orders') || []
  
  // 合并并去重
  return Array.from(orderMap.values())
}
```

**潜在问题**：
- ❌ 如果订单只存在于 `mock_orders` 中，但不在 `orders` 中
- ❌ 如果下单逻辑写入的是其他存储键，而过滤逻辑读取的是 `orders`

**排查建议**：
检查下单时的存储逻辑（`order-success/index.js`）：

**文件**：`miniprogram/pages/order-success/index.js`（第669-786行）

```javascript
// 🔍 关键：查找订单保存到哪里
console.log('[order-success] 保存订单到本地存储')

// ⚠️ 需要确认保存到了正确的 key
let existingOrders = wx.getStorageSync('orders') || []  // ❓ 是否保存到 'orders'？
existingOrders.push(newOrder)
wx.setStorageSync('orders', existingOrders)
```

**验证脚本**：
```javascript
// 检查订单分布在哪些存储键中
const keys = ['mock_orders', 'orders', 'pending_orders', 'completed_orders']
keys.forEach(key => {
  const data = wx.getStorageSync(key) || []
  console.log(`${key}: ${data.length} 个订单`)
})
```

**✅ 已确认**：订单保存逻辑
- **文件**：`miniprogram/pages/order-success/index.js` 第753行
- **保存位置**：`wx.setStorageSync('pending_orders', pendingOrders)`
- **结论**：✅ 订单正确保存到 `'pending_orders'`，`getAllOrders()` 会自动合并

---

### ⚠️ 4. 状态过滤问题

#### **4.1 终态订单被过滤**

**文件**：`miniprogram/utils/order-helper.js`（第469-479行）

```javascript
// 🎯 过滤终态订单（除非明确要求包含）
if (!includeCompleted) {
  const TERMINAL_STATES = ['completed', 'refunded', 'cancelled']
  allOrders = allOrders.filter(order => !TERMINAL_STATES.includes(order.status))
}
```

**问题**：
- ❌ 如果订单状态是 `'completed'`、`'refunded'` 或 `'cancelled'`，用户端和画师端默认看不到
- ✅ 管理端和客服端能看到（因为它们可能传入了 `includeCompleted: true`）

**排查建议**：
检查用户端和画师端是否需要显示已完成订单：

**用户端**（`miniprogram/pages/order-list/index.js`）：
```javascript
// 🔍 查找调用 prepareOrdersForPage 的地方
let allOrders = orderHelper.prepareOrdersForPage({
  role: 'customer',
  userId: userId
  // ❓ 是否传入 includeCompleted: true？
})
```

**画师端**（`miniprogram/pages/workspace/index.js`）：
```javascript
let myOrders = orderHelper.prepareOrdersForPage({
  role: userRole,
  userId: currentUserId
  // ❓ 是否传入 includeCompleted: true？
})
```

---

### ⚠️ 5. 个别商品 ID 不匹配

#### **5.1 商品的 artistId 与实际画师 ID 不一致**

**潜在场景**：
1. 商品编辑时 `artistId` 未正确设置
2. 画师ID在申请通过后发生变化，但商品未同步更新
3. 商品的 `artistId` 是用户ID，但画师实际使用的是画师编号

**排查脚本**：
```javascript
// 检查商品和订单的 artistId 是否匹配
const products = wx.getStorageSync('mock_products') || []
const orders = wx.getStorageSync('orders') || []
const artistApplications = wx.getStorageSync('artist_applications') || []

// 找出所有已通过的画师ID
const approvedArtistIds = artistApplications
  .filter(app => app.status === 'approved')
  .map(app => String(app.userId))

console.log('✅ 已通过的画师ID:', approvedArtistIds)

// 检查商品的 artistId 是否在已通过列表中
products.forEach(p => {
  if (!approvedArtistIds.includes(String(p.artistId))) {
    console.log(`❌ 商品 "${p.name}" 的 artistId "${p.artistId}" 不在已通过画师列表中`)
  }
})

// 检查订单的 artistId 是否在已通过列表中
orders.forEach(o => {
  if (!approvedArtistIds.includes(String(o.artistId))) {
    console.log(`❌ 订单 "${o.id}" 的 artistId "${o.artistId}" 不在已通过画师列表中`)
  }
})
```

---

#### **5.2 productId 不匹配**

**潜在场景**：
- 订单的 `productId` 与商品表中的 `id` 不一致
- 商品已被删除

**排查脚本**：
```javascript
const products = wx.getStorageSync('mock_products') || []
const orders = wx.getStorageSync('orders') || []
const productIds = new Set(products.map(p => String(p.id)))

orders.forEach(o => {
  if (!productIds.has(String(o.productId))) {
    console.log(`❌ 订单 "${o.id}" 的 productId "${o.productId}" 不存在于商品表中`)
  }
})
```

---

## 🔥 高风险问题汇总

### 🚨 问题1：artistId 为空（高风险）

**位置**：`miniprogram/pages/order-success/index.js` 第655行

```javascript
artistId: String(orderInfo.artistId || ''),  // ❌ 如果为空，画师端看不到
```

**影响**：
- ✅ 管理端能看到（不过滤 artistId）
- ✅ 客服端能看到（不过滤 artistId）
- ❌ 画师端看不到（过滤 `order.artistId === userId`）
- ✅ 用户端能看到（过滤 `order.buyerId === userId`）

**修复建议**：
1. 在下单前验证 `artistId` 不为空
2. 添加错误日志：

```javascript
// 修改 order-success/index.js
if (!orderInfo.artistId || orderInfo.artistId === '') {
  console.error('❌ [下单异常] artistId 为空，画师端将无法看到此订单', {
    productId: orderInfo.productId,
    productName: orderInfo.productName,
    orderNo: orderInfo.orderNo
  })
  wx.showModal({
    title: '警告',
    content: '商品画师信息缺失，订单可能无法正常分配',
    showCancel: false
  })
}

artistId: String(orderInfo.artistId || ''),
```

---

### 🚨 问题2：终态订单被过滤（中风险）

**位置**：`miniprogram/utils/order-helper.js` 第470-474行

**影响**：
- 用户端和画师端默认看不到 `completed`、`refunded`、`cancelled` 订单
- 管理端和客服端可能能看到（如果传入 `includeCompleted: true`）

**修复建议**：
检查用户端和画师端是否需要显示历史订单：

```javascript
// 用户端 order-list/index.js
let allOrders = orderHelper.prepareOrdersForPage({
  role: 'customer',
  userId: userId,
  includeCompleted: true  // ✅ 显示所有订单
})

// 画师端 workspace/index.js
let myOrders = orderHelper.prepareOrdersForPage({
  role: userRole,
  userId: currentUserId,
  includeCompleted: true  // ✅ 显示所有订单
})
```

---

### 🚨 问题3：订单存储键不一致（中风险）

**潜在问题**：
- 下单时保存到 `'orders'`
- 但某些情况下保存到了 `'mock_orders'` 或其他键

**修复建议**：
统一订单存储逻辑，确保所有下单路径都保存到 `'orders'`：

```javascript
// 建议在 order-success/index.js 中统一使用：
const UNIFIED_ORDER_KEY = 'orders'

let existingOrders = wx.getStorageSync(UNIFIED_ORDER_KEY) || []
existingOrders.push(newOrder)
wx.setStorageSync(UNIFIED_ORDER_KEY, existingOrders)

console.log(`✅ 订单已保存到 ${UNIFIED_ORDER_KEY}，总订单数: ${existingOrders.length}`)
```

---

## 🛠️ 立即执行的诊断脚本

将以下脚本复制到微信开发者工具 Console 中执行：

```javascript
// ===== 订单可见性全面诊断 =====

console.log('========== 订单可见性诊断 ==========')

// 1. 检查订单分布
const keys = ['mock_orders', 'orders', 'pending_orders', 'completed_orders']
const allOrdersMap = {}
keys.forEach(key => {
  const data = wx.getStorageSync(key) || []
  allOrdersMap[key] = data
  console.log(`${key}: ${data.length} 个订单`)
})

// 2. 检查最近3个订单的关键字段
const recentOrders = (wx.getStorageSync('orders') || []).slice(-3)
console.log('\n========== 最近3个订单详情 ==========')
recentOrders.forEach((o, index) => {
  console.log(`\n订单 ${index + 1}:`)
  console.log(`  ID: ${o.id}`)
  console.log(`  商品: ${o.productName}`)
  console.log(`  buyerId: "${o.buyerId}" (类型: ${typeof o.buyerId})`)
  console.log(`  artistId: "${o.artistId}" (类型: ${typeof o.artistId})`)
  console.log(`  serviceId: "${o.serviceId || '无'}" (类型: ${typeof o.serviceId})`)
  console.log(`  状态: ${o.status}`)
  console.log(`  productId: ${o.productId}`)
})

// 3. 检查 artistId 为空的订单
const allOrders = [...allOrdersMap['orders'], ...allOrdersMap['mock_orders']]
const emptyArtistIds = allOrders.filter(o => !o.artistId || o.artistId === '')
console.log(`\n========== artistId 为空的订单 ==========`)
console.log(`总数: ${emptyArtistIds.length}`)
emptyArtistIds.forEach(o => {
  console.log(`  订单 ${o.id}: ${o.productName}`)
})

// 4. 检查商品的 artistId
const products = wx.getStorageSync('mock_products') || []
console.log(`\n========== 商品 artistId 检查 ==========`)
const productsWithoutArtist = products.filter(p => !p.artistId || p.artistId === '')
console.log(`无 artistId 的商品数: ${productsWithoutArtist.length}`)
productsWithoutArtist.forEach(p => {
  console.log(`  商品 "${p.name}" (ID: ${p.id}): artistId 缺失`)
})

// 5. 检查订单和商品的 ID 匹配
console.log(`\n========== 订单-商品 ID 匹配检查 ==========`)
const productIds = new Set(products.map(p => String(p.id)))
const mismatchOrders = allOrders.filter(o => !productIds.has(String(o.productId)))
console.log(`productId 不匹配的订单数: ${mismatchOrders.length}`)
mismatchOrders.forEach(o => {
  console.log(`  订单 ${o.id}: productId "${o.productId}" 不存在`)
})

// 6. 用户端视角模拟（假设当前用户ID是 '1001'）
const currentUserId = wx.getStorageSync('userId')
console.log(`\n========== 用户端视角（userId: ${currentUserId}） ==========`)
const userOrders = allOrders.filter(o => String(o.buyerId) === String(currentUserId))
console.log(`可见订单数: ${userOrders.length}`)

// 7. 画师端视角模拟（假设当前用户ID是 '1001'）
console.log(`\n========== 画师端视角（artistId: ${currentUserId}） ==========`)
const artistOrders = allOrders.filter(o => String(o.artistId) === String(currentUserId))
console.log(`可见订单数: ${artistOrders.length}`)

console.log('\n========== 诊断完成 ==========')
```

---

## 📝 修复优先级

| 优先级 | 问题 | 影响范围 | 修复难度 |
|--------|------|----------|----------|
| 🔴 **P0** | artistId 为空 | 画师端完全看不到订单 | 低 |
| 🟡 **P1** | 终态订单被过滤 | 用户/画师看不到历史订单 | 低 |
| 🟡 **P1** | 商品 artistId 缺失 | 新订单画师端不可见 | 中 |
| 🟢 **P2** | 订单存储键不一致 | 可能导致部分订单丢失 | 低 |
| 🟢 **P2** | productId 不匹配 | 订单详情显示异常 | 低 |

---

## ✅ 下一步行动

1. **立即执行诊断脚本**，确定问题根因
2. **修复 artistId 为空问题**（P0）
3. **检查是否需要显示历史订单**（P1）
4. **补全商品 artistId**（P1）
5. **统一订单存储逻辑**（P2）

---

**生成者**：AI 助手  
**审核者**：待审核  
**版本**：v1.0

