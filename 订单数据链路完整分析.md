# 订单数据链路完整分析

## 🎯 核心问题：多用户场景下的数据隔离

### ⚠️ 当前问题识别

#### 问题1：工作台显示所有订单
**当前逻辑**：
```javascript
// workspace/index.js - loadPendingStats()
let allOrders = wx.getStorageSync('pending_orders') || []
```

**问题**：
- ❌ 所有用户的订单都存在同一个 `pending_orders` 中
- ❌ 画师A能看到画师B的订单
- ❌ 没有按照画师ID筛选订单

**正确逻辑应该是**：
```javascript
// 只加载属于当前画师的订单
const currentUserId = wx.getStorageSync('userId')
let allOrders = wx.getStorageSync('pending_orders') || []
let myOrders = allOrders.filter(order => order.artistId === currentUserId)
```

---

#### 问题2：订单创建时缺少画师ID
**当前逻辑**：
```javascript
// order-success/index.js
const newOrder = {
  artistName: orderInfo.artistName,  // ✅ 有画师昵称
  // ❌ 缺少 artistId
}
```

**问题**：
- 没有保存画师的 userId
- 无法按画师ID筛选订单

**需要添加**：
```javascript
const newOrder = {
  artistId: orderInfo.artistId,      // ✅ 添加画师ID
  artistName: orderInfo.artistName,
  artistAvatar: orderInfo.artistAvatar,  // ✅ 添加画师头像
}
```

---

#### 问题3：客服信息分配逻辑缺失
**当前逻辑**：
```javascript
serviceName: '待分配',
serviceAvatar: '/assets/default-avatar.png'
```

**问题**：
- ❌ 所有订单客服都是"待分配"
- ❌ 没有客服分配逻辑
- ❌ 客服无法查看自己负责的订单

**需要实现**：
1. 管理员分配客服给订单
2. 保存 `serviceId` 和 `serviceName`
3. 客服工作台只显示自己负责的订单

---

## 🔄 完整数据流程分析

### 场景1：用户A下单，画师B接单

```
1. 用户A浏览商品
   ↓
2. 商品数据包含：
   {
     artistId: 'user-1001',        // 画师B的ID
     artistName: '画师小明',
     artistAvatar: 'https://...'
   }
   ↓
3. 用户A点击"立即购买"
   ↓
4. 跳转到 order-success 页面，携带参数：
   - productId
   - artistId  ← ⚠️ 目前缺失
   - artistName
   - artistAvatar  ← ⚠️ 目前缺失
   ↓
5. 保存订单：
   {
     id: '202510271529058195',
     buyerName: '用户A',          // ✅ 下单者
     buyerAvatar: 'https://...',
     buyerOpenId: 'oXXXX...',
     
     artistId: 'user-1001',       // ✅ 画师B的ID
     artistName: '画师小明',
     artistAvatar: 'https://...',
     
     serviceId: '',               // ⚠️ 待分配
     serviceName: '待分配',
     serviceAvatar: '/assets/default-avatar.png'
   }
   ↓
6. 画师B打开工作台
   ↓
7. 筛选订单：
   const myOrders = allOrders.filter(o => o.artistId === currentUserId)
   ↓
8. 显示：只有画师B的订单
```

---

### 场景2：管理员分配客服

```
1. 管理员在后台查看订单
   ↓
2. 选择订单 → 分配客服
   ↓
3. 更新订单数据：
   {
     serviceId: 'user-2001',      // 客服小红的ID
     serviceName: '客服小红',
     serviceAvatar: 'https://...'
   }
   ↓
4. 客服小红打开工作台
   ↓
5. 筛选订单：
   const myOrders = allOrders.filter(o => o.serviceId === currentUserId)
   ↓
6. 显示：只有客服小红负责的订单
```

---

## 🐛 当前代码存在的数据泄漏风险

### 风险1：画师看到所有订单
```javascript
// ❌ 错误示例
loadPendingStats() {
  let allOrders = wx.getStorageSync('pending_orders') || []
  // 直接显示所有订单，没有筛选
}
```

### 风险2：客服分配逻辑缺失
- 没有 `serviceId` 字段
- 无法按客服ID筛选
- 客服无法查看自己的订单

### 风险3：商品创建时缺少画师ID
```javascript
// product-edit/index.js
// ❌ 可能缺少 artistId
const product = {
  artistName: userInfo.nickName,  // 只有昵称
  // 缺少 artistId
}
```

---

## ✅ 正确的数据结构

### 订单数据结构（完整版）
```javascript
{
  // 订单基础信息
  id: '202510271529058195',
  productId: 'prod-001',
  productName: 'Q版头像定制',
  productImage: 'data:image/jpeg;base64,...',
  spec: '大头/手机壁纸',
  price: '88.00',
  quantity: 1,
  
  // 下单者信息（买家）
  buyerId: 'user-3001',                    // ✅ 买家ID
  buyerName: '用户A',
  buyerAvatar: 'https://...',
  buyerOpenId: 'oXXXX...',
  
  // 画师信息
  artistId: 'user-1001',                   // ✅ 画师ID（关键）
  artistName: '画师小明',
  artistAvatar: 'https://...',
  
  // 客服信息
  serviceId: 'user-2001',                  // ✅ 客服ID（关键）
  serviceName: '客服小红',
  serviceAvatar: 'https://...',
  
  // 时间信息
  createTime: '2025-10-27 15:29:05',
  deadline: '2025-10-30 15:29',
  
  // 状态信息
  status: 'inProgress',
  statusText: '进行中',
  workCompleted: false,
  workCompleteTime: ''
}
```

---

## 🔧 需要修复的文件

### 1. order-success/index.js
**添加画师ID和头像**：
```javascript
const newOrder = {
  // ...其他字段
  
  // ✅ 添加画师完整信息
  artistId: options.artistId || '',
  artistName: decodeURIComponent(options.artistName || '画师'),
  artistAvatar: decodeURIComponent(options.artistAvatar || '/assets/default-avatar.png'),
  
  // ✅ 添加买家ID
  buyerId: userId,
  buyerName: userInfo.nickName || '客户',
  buyerAvatar: userInfo.avatarUrl || '/assets/default-avatar.png',
}
```

### 2. workspace/index.js
**按角色筛选订单**：
```javascript
loadPendingStats() {
  const currentUserId = wx.getStorageSync('userId')
  const { userRole } = this.data
  
  let allOrders = wx.getStorageSync('pending_orders') || []
  
  // ✅ 根据角色筛选订单
  let myOrders = []
  
  if (userRole === 'artist') {
    // 画师：只看自己的订单
    myOrders = allOrders.filter(o => o.artistId === currentUserId)
  } else if (userRole === 'service') {
    // 客服：只看自己负责的订单
    myOrders = allOrders.filter(o => o.serviceId === currentUserId)
  }
  
  // 计算订单状态
  myOrders = orderStatusUtil.calculateOrdersStatus(myOrders)
  
  // ...
}
```

### 3. product-detail/index.js
**传递画师完整信息**：
```javascript
buyNow() {
  const product = this.data.product
  
  wx.redirectTo({
    url: `/pages/order-success/index?` +
      `productId=${product.id}&` +
      `productName=${encodeURIComponent(product.name)}&` +
      `artistId=${product.artistId || ''}&` +  // ✅ 添加
      `artistName=${encodeURIComponent(product.artistName || '画师')}&` +
      `artistAvatar=${encodeURIComponent(product.artistAvatar || '')}&`  // ✅ 添加
      // ...其他参数
  })
}
```

### 4. product-edit/index.js
**商品创建时保存画师ID**：
```javascript
const userId = wx.getStorageSync('userId')
const userInfo = wx.getStorageSync('userInfo') || {}

const product = {
  // ...其他字段
  artistId: userId,                      // ✅ 保存画师ID
  artistName: userInfo.nickName || '画师',
  artistAvatar: userInfo.avatarUrl || '/assets/default-avatar.png'
}
```

---

## 📝 测试场景

### 测试1：多画师场景
```javascript
// 创建两个画师账号
// 画师A: userId = 1001
// 画师B: userId = 1002

// 画师A创建商品 → artistId = 1001
// 用户下单画师A的商品 → order.artistId = 1001

// 画师A登录工作台 → 只看到 artistId = 1001 的订单 ✅
// 画师B登录工作台 → 看不到画师A的订单 ✅
```

### 测试2：客服场景
```javascript
// 客服小红: userId = 2001
// 管理员分配订单给客服小红 → order.serviceId = 2001

// 客服小红登录工作台 → 只看到 serviceId = 2001 的订单 ✅
```

---

## 🎯 总结

### ❌ 当前问题
1. 工作台显示所有订单，没有按用户筛选
2. 订单缺少 `artistId` 和 `serviceId`
3. 商品缺少 `artistId`
4. 客服功能不完整

### ✅ 需要修复
1. 订单数据添加 `artistId`、`buyerId`、`serviceId`
2. 工作台按角色筛选订单
3. 商品数据添加画师完整信息
4. 完善客服工作台功能

### 🚀 优先级
1. **高优先级**：修复数据隔离问题（防止数据泄漏）
2. **中优先级**：完善客服功能
3. **低优先级**：优化UI和交互

