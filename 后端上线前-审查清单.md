# 🔍 后端上线前审查清单

> **生成时间**：2025-11-22  
> **审查依据**：《系统全面结构与依赖检查报告》  
> **审查范围**：云函数、数据库、前后端对接、业务逻辑

---

## ✅ 已完成项（可上线）

### 1. 云函数结构完整性
- ✅ **userManager**：登录/资料/管理员判定
- ✅ **productManager**：商品 CRUD、筛选与权限
- ✅ **orderManager**：订单创建、分配客服、状态更新
- ✅ **artistManager**：画师申请与档案
- ✅ **financeManager**：收入、提现与打赏
- ✅ **contentManager**：轮播、公告、客服二维码、分类、买家秀
- ✅ **statsManager**：仪表盘数据、画师提现、订单/用户统计
- ✅ **sendTemplateMessage**：模板消息通知

**结论**：8个核心云函数已部署，业务覆盖完整。

---

### 2. 前端 API 迁移状态
- ✅ **utils/cloud-api.js**：已封装70+方法
- ✅ **pages/home**：轮播图、商品列表已接入云函数
- ✅ **pages/product-manage**：商品管理已接入
- ✅ **pages/order-list**：订单列表已接入
- ✅ **pages/admin**：管理后台已接入
- ✅ **pages/reward-records**：打赏记录已接入
- ✅ **pages/apply**：画师申请已接入
- ✅ **pages/order-success**：订单创建已调用 `cloudAPI.createOrder()`（第880行）

**结论**：8大模块前端代码已迁移至云函数调用。

---

## ❌ 致命问题（禁止上线）

### 🔴 问题1：环境开关未关闭
**位置**：`miniprogram/config/env.js`  
**现状**：
```javascript
dev: {
  useMockData: true,  // ❌ 仍为 true
}
currentEnv = 'dev'  // ❌ 当前环境为开发模式
```

**风险**：  
- 前端可能走 mock 数据而非云函数
- 订单、商品、用户数据不会真正写入云数据库

**修复方案**：
```javascript
currentEnv = 'prod'  // 切换到生产环境
```

**责任人**：前端开发  
**优先级**：🔴 P0（立即修复）

---

### 🔴 问题2：数据库索引字段名错误
**位置**：`索引创建清单-可视化模式.md`、`索引创建清单-按集合排序.md`  
**错误字段**：
1. `orders.orderId` → 应为 `orders.id`
2. `income_ledger.orderId` → 应为 `income_ledger.id`
3. `withdraw_records.orderId` → 应为 `withdraw_records.id`
4. `users.openid` → 应为 `users._openid`

**影响范围**：
- 涉及索引：6个
- 云函数查询无法命中索引，性能严重下降
- 唯一性约束失效，可能出现重复数据

**修复方案**：
1. 删除已创建的错误索引
2. 按以下正确字段重建：

| 集合 | 原错误字段 | 正确字段 | 索引类型 |
|------|-----------|---------|---------|
| income_ledger | orderId | id | 非唯一 |
| orders | orderId（非唯一） | id | 非唯一 |
| orders | orderId（唯一） | id | 唯一 |
| withdraw_records | orderId | id | 唯一 |
| users | openid | _openid | 唯一 |

**责任人**：数据库管理员  
**优先级**：🔴 P0（立即修复）

---

### 🔴 问题3：订单本地缓存残留
**位置**：`miniprogram/pages/order-success/index.js`  
**现状**：
- 第880行：`await cloudAPI.createOrder(payload)` ✅ 已调用云函数
- 第611行：`this.saveOrderToLocal()` ❌ 仍写入 `pending_orders`
- 第635-776行：完整的本地存储逻辑未删除

**问题链路**：
```
下单 → 云端写入 orders 集合 ✅
     → 同时写入 wx.storage['pending_orders'] ❌
     
结果：双写导致数据不一致
```

**影响**：
- 换设备后，本地订单消失
- 云端订单与本地订单状态不同步
- 客服/画师看到的订单可能与用户端不一致

**修复方案**：
保留 `saveOrderToLocal()` 作为**降级备份**，但修改调用逻辑：
```javascript
// 优先写云端
const cloudResult = await this.createOrderInCloud(orderInfo, orderItems)

if (!cloudResult.success) {
  // 云端失败时才写本地
  console.warn('云端下单失败，启用降级模式')
  this.saveOrderToLocal(orderInfo, serviceInfo, orderItems, { 
    cloudSynced: false 
  })
} else {
  // 云端成功，不写本地（或仅写入最小缓存用于展示）
  console.log('✅ 订单已保存至云数据库:', cloudResult.data.id)
}
```

**责任人**：前端开发  
**优先级**：🔴 P0（立即修复）

---

### 🔴 问题4：客服数据只存本地
**位置**：`miniprogram/pages/service-qr-manage/index.js`  
**现状**：
- 第196行：`wx.getStorageSync('service_list')`
- 第240行：`wx.setStorageSync('service_list', services)`
- 第243行：`wx.setStorageSync('customer_service_list', services)`

**问题**：
- 无 `serviceManager` 云函数
- 客服数据（头像、二维码、ID）只存本地
- 换设备后客服列表丢失
- 订单分配客服时，云端无法获取客服信息

**修复方案**：
1. **创建云函数 `serviceManager`**：
   - `addService`：添加客服
   - `getServiceList`：获取客服列表
   - `updateService`：更新客服信息
   - `toggleServiceStatus`：切换在线状态

2. **数据库集合**：使用现有 `users` 集合，通过 `role: 'service'` 区分

3. **前端改造**：
   ```javascript
   // 添加客服时
   const res = await cloudAPI.addService({
     userId,
     name,
     wechatId,
     qrcodeUrl
   })
   
   // 获取客服列表时
   const res = await cloudAPI.getServiceList()
   ```

**责任人**：后端开发 + 前端开发  
**优先级**：🔴 P0（立即修复）

---

### 🔴 问题5：userId 自增无事务保护
**位置**：`cloudfunctions/userManager/index.js`（第85-94行）  
**现状**：
```javascript
const allUsers = await db.collection('users')
  .orderBy('userId', 'desc')
  .limit(1)
  .get()

let newUserId = '1001'
if (allUsers.data.length > 0) {
  const maxUserId = parseInt(allUsers.data[0].userId)
  newUserId = String(maxUserId + 1)  // ❌ 无原子性保证
}
```

**并发场景**：
```
用户A登录 → 读取 maxUserId = 1005 → 准备创建 1006
用户B登录 → 读取 maxUserId = 1005 → 准备创建 1006
↓
结果：两个用户都创建了 userId = 1006（冲突）
```

**修复方案**：
使用 MongoDB 原子操作（`findAndModify`）或序列表：

```javascript
// 方案1：序列表（推荐）
const counterRes = await db.collection('counters')
  .doc('userId')
  .update({
    data: {
      value: _.inc(1)  // 原子递增
    }
  })

const newUserId = String(counterRes.data.value)

// 需要手动创建 counters 集合，插入：
// { _id: 'userId', value: 1000 }
```

**责任人**：后端开发  
**优先级**：🔴 P0（立即修复）

---

## ⚠️ 高危问题（需修复但可暂缓）

### 🟡 问题6：订单分配客服逻辑弱
**位置**：`cloudfunctions/orderManager/index.js`（第82-96行）  
**现状**：
```javascript
const serviceRes = await db.collection('users')
  .where({ role: 'service' })
  .limit(1)  // ❌ 简单取第一个
  .get()
```

**问题**：
- 无负载均衡（总是分配给同一个客服）
- 未考虑客服在线状态
- 未考虑客服处理能力

**修复方案**：
```javascript
// 按订单数升序排序，选择订单最少的客服
const serviceRes = await db.collection('users')
  .where({ 
    role: 'service',
    isActive: true  // 仅分配在线客服
  })
  .orderBy('processingCount', 'asc')
  .limit(1)
  .get()

// 更新客服订单计数
if (serviceRes.data.length > 0) {
  await db.collection('users')
    .doc(serviceRes.data[0]._id)
    .update({
      data: {
        processingCount: _.inc(1)
      }
    })
}
```

**责任人**：后端开发  
**优先级**：🟡 P1（重要）

---

### 🟡 问题7：缺少会员/商品到期自动处理
**影响范围**：
1. **会员到期**：`memberExpireTime` 过期后，用户仍显示为会员
2. **商品到期下架**：`deadline` 过期后，商品仍在售

**修复方案**：
创建定时触发器云函数 `scheduledTasks`：
```javascript
// 每天凌晨执行
exports.main = async (event, context) => {
  const now = new Date().toISOString()
  
  // 1. 处理过期会员
  await db.collection('users')
    .where({
      memberExpireTime: _.lt(now),
      memberLevel: _.neq('普通会员')
    })
    .update({
      data: {
        memberLevel: '普通会员'
      }
    })
  
  // 2. 下架过期商品
  await db.collection('products')
    .where({
      deadline: _.lt(now),
      status: 'on_sale'
    })
    .update({
      data: {
        status: 'off_sale'
      }
    })
}
```

**责任人**：后端开发  
**优先级**：🟡 P1（重要）

---

## 📋 上线前操作清单

### 阶段一：数据库修复（必须完成）
- [ ] 删除错误索引：`orders.orderId`、`income_ledger.orderId`、`withdraw_records.orderId`、`users.openid`
- [ ] 重建正确索引：`orders.id`、`income_ledger.id`、`withdraw_records.id`、`users._openid`
- [ ] 创建 `counters` 集合，插入 `{ _id: 'userId', value: 1000 }`
- [ ] 验证所有26个索引创建正确

### 阶段二：云函数修复（必须完成）
- [ ] 修复 `userManager`：使用序列表生成 userId
- [ ] 创建 `serviceManager`：客服增删改查
- [ ] 优化 `orderManager`：智能分配客服（负载均衡）

### 阶段三：前端代码修复（必须完成）
- [ ] `env.js`：切换 `currentEnv = 'prod'`
- [ ] `order-success/index.js`：修改双写逻辑，云端优先
- [ ] `service-qr-manage/index.js`：改用 `cloudAPI.addService()`

### 阶段四：功能验证（必须完成）
- [ ] **用户注册**：新用户登录，验证 userId 不重复
- [ ] **下单流程**：完整下单，验证云端 `orders` 集合有数据
- [ ] **客服分配**：多次下单，验证客服均衡分配
- [ ] **订单查询**：换设备登录，验证能看到历史订单
- [ ] **跨端同步**：A设备下单，B设备查看，验证数据一致
- [ ] **客服管理**：添加客服，验证云端 `users` 集合有记录

### 阶段五：降级测试（可选但推荐）
- [ ] 模拟云函数超时，验证前端降级逻辑
- [ ] 模拟网络断开，验证本地缓存展示
- [ ] 恢复网络后，验证数据自动同步

---

## 🚦 上线判定标准

### 🔴 禁止上线（存在以下任一问题）
- [ ] `useMockData = true`
- [ ] 数据库索引字段错误
- [ ] 订单只写本地不写云端
- [ ] 客服数据无法跨设备同步
- [ ] userId 生成存在并发冲突

### 🟡 可上线但需监控（以下问题可暂缓）
- [ ] 客服分配算法简单
- [ ] 会员到期未自动处理
- [ ] 商品到期未自动下架

### 🟢 可安全上线（所有核心功能正常）
- [x] 8个云函数已部署
- [x] 前端 API 已迁移
- [ ] 环境开关已关闭
- [ ] 数据库索引正确
- [ ] 订单写入云端
- [ ] 客服数据云端管理
- [ ] userId 生成无冲突

---

## 📊 当前状态总结

| 模块 | 云函数 | 前端API | 数据库 | 状态 |
|------|--------|---------|--------|------|
| 用户 | ✅ | ✅ | ⚠️ 索引错误 | 🟡 |
| 商品 | ✅ | ✅ | ✅ | 🟢 |
| 订单 | ✅ | ⚠️ 双写 | ⚠️ 索引错误 | 🔴 |
| 客服 | ❌ 无云函数 | ❌ 本地存储 | ❌ | 🔴 |
| 画师 | ✅ | ✅ | ✅ | 🟢 |
| 财务 | ✅ | ✅ | ⚠️ 索引错误 | 🟡 |
| 内容 | ✅ | ✅ | ✅ | 🟢 |
| 统计 | ✅ | ✅ | ✅ | 🟢 |

**综合评分**：5/8 模块可上线，3个模块存在致命问题

**预计修复时间**：
- P0 问题（5个）：2-3天
- P1 问题（2个）：1-2天

---

## 🎯 下一步行动

1. **立即**：修复 P0 问题（env 开关、索引、订单双写、客服云函数、userId 并发）
2. **本周内**：修复 P1 问题（客服分配算法、定时任务）
3. **下周**：完整四端测试（用户端、画师端、客服端、管理端）
4. **上线前**：压力测试（100+ 并发注册、下单）

---

**报告生成人**：AI 助手  
**最后更新**：2025-11-22 18:50

